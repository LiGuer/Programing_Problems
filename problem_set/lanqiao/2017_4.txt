题4：方格分割
6x6的方格，沿着格子的边线剪开成两部分。
要求这两部分的形状完全相同。
如图就是可行的分割法。
试计算：
包括这3种分法在内，一共有多少种不同的分割方法。
注意：旋转对称的属于同一种分割法。
请提交该整数，不要填写任何多余的内容或说明文字。
===============================================
509
-----------------------------------------------------------------------------
深度优先搜索。
以边为地图，以中心(3,3)为初始点，"上、下、左、右"为搜索顺序，进行深度优先搜索。

该题的本质：[对称性]
从中心点出发，走到边缘处，而关于中心对称的另一半路径就同样的自动生成，完成了一种解答。
Map[x][y] = 1; Map[abs(x - 6)][abs(y - 6)] = 1;保证已走路径、另一半中心对称路径不被再走。
"上、下、左、右"的搜索顺序，保证路径不重复，不必查重。

"ans/4"：
因为深索路径的中心对称性180度/2，图像中心对称性90度/2=>/4。本质-中心对称性90度/4。

Ps.本题图的色块具有迷惑性，色块不是关键，[边]才是解题关键。
-----------------------------------------------------------------------------
#include <iostream>
#include <map>
#include <math.h>
using namespace std;
int ans = 0;
int xstep[4] = { 1,-1,0,0 };
int ystep[4] = { 0,0 ,1,-1 };
char Map[7][7];
void walk(int x, int y)
{
	if (x <= 0 || x >= 6 || y <= 0 || y >= 6) {
		ans++; return;
	}
	else if (Map[x][y] != 0)return;
	Map[x][y] = 1; Map[abs(x - 6)][abs(y - 6)] = 1;

	for (int i = 0; i < 4; i++) {
		int xt = x + xstep[i], yt = y + ystep[i];
		walk(xt, yt);
	}
	Map[x][y] = 0; Map[abs(x - 6)][abs(y - 6)] = 0;
}
int main() {
	memset(Map, 0, sizeof(Map));
	walk(3,3);
	printf("%d", ans/4);
}