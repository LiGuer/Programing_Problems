# 743. Network Delay Time

## Problem 

You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target.

We will send a signal from a given node k. Return the minimum time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1.

Example 1:
```
Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
Output: 2
```

Example 2:
```
Input: times = [[1,2,1]], n = 2, k = 1
Output: 1
```

Example 3:
```
Input: times = [[1,2,1]], n = 2, k = 2
Output: -1
```

Constraints:

- 1 <= k <= n <= 100
- 1 <= times.length <= 6000
- times[i].length == 3
- 1 <= ui, vi <= n
- ui != vi
- 0 <= wi <= 100
- All the pairs (ui, vi) are unique. (i.e., no multiple edges.)

## Tag
```graph```, ```shortest paths```

## Algorithm

Single-Source Shortest Paths

Dijkstra

## Code
```java
class Solution {
  public int networkDelayTime(int[][] g, int n, int k) {
    int m = g.length;

    int[][] G = new int[n][n];

    for (int i = 0; i < n; i++) {
      Arrays.fill(G[i], 0xFFFFFFF);
    }

    for (int[] t : g) {
      G[t[0] - 1][t[1] - 1] = t[2];
    }

    int[] dis = new int[n];
    boolean[] mark = new boolean[n];

    for (int i = 0; i < n; i++) {
      dis[i] = 0xFFFFFFF;
    }

    dis[k - 1] = 0;

    for (int i = 0; i < n; i++) {

      int x = -1;

      for (int j = 0; j < n; j++) {
        if (!mark[j] && (x == -1 || dis[j] < dis[x])) {
          x = j;
        }
      }

      mark[x] = true;

      for (int j = 0; j < n; j++) {
        dis[j] = Math.min(dis[j], dis[x] + G[x][j]);
      }

    }

    int ans = Arrays.stream(dis).max().getAsInt();
    return ans == 0xFFFFFFF ? -1 : ans;
  }
}
```